name: Auto merge PRs

on:
  workflow_run:
    workflows: ["Security Checks"]
    types: [requested, in_progress, completed]

permissions:
  actions: read
  checks: read
  contents: write
  issues: write
  pull-requests: write

jobs:
  automerge:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo
            const run = context.payload.workflow_run
            const action = context.payload.action
            const runUrl = run.html_url
            const runId = run.id
            const checksOk = run.conclusion === "success"

            const prs = run.pull_requests || []
            if (prs.length === 0) {
              console.log("No PRs for this workflow run")
              return
            }

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms))
            const conflictMarker = "<!-- automerge-conflict -->"
            const statusMarker = (stage) => `<!-- automerge-run:${runId}:${stage} -->`
            const mergeMarker = (stage) => `<!-- automerge-merge:${runId}:${stage} -->`
            const virusMarker = (stage) => `<!-- automerge-virus:${runId}:${stage} -->`

            async function getPr(number) {
              return (await github.rest.pulls.get({ owner, repo, pull_number: number })).data
            }

            async function listComments(number) {
              const { data } = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: number,
                per_page: 100
              })
              return data
            }

            async function commentOnce(number, marker, lines) {
              const comments = await listComments(number)
              if (comments.some((comment) => comment.body?.includes(marker))) {
                console.log(`Comment already exists for PR #${number} (${marker})`)
                return false
              }
              const body = [marker, ...lines].join("\n")
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body
              })
              return true
            }

            async function postConflictComment(pr) {
              const lines = [
                "FR: Cette PR a des conflits avec la branche cible. Merci de les resoudre puis de mettre a jour la PR.",
                "EN: This PR has merge conflicts with the base branch. Please resolve them and update the PR."
              ]
              const posted = await commentOnce(pr.number, conflictMarker, lines)
              if (posted) {
                console.log(`Posted conflict comment on PR #${pr.number}`)
              }
            }

            async function getRunJobs(runId) {
              const { data } = await github.rest.actions.listJobsForWorkflowRun({
                owner,
                repo,
                run_id: runId,
                per_page: 100
              })
              return data.jobs || []
            }

            function formatJobSummary(jobs) {
              if (!jobs.length) return ["Jobs: none"]
              return ["Jobs:", ...jobs.map((job) => `- ${job.name}: ${job.conclusion || job.status}`)]
            }

            async function waitForMergeable(number, attempts = 12, delayMs = 5000) {
              let pr
              for (let i = 0; i < attempts; i++) {
                pr = await getPr(number)
                if (pr.merged) {
                  console.log(`PR #${number} already merged`)
                  return pr
                }
                if (pr.mergeable === true && pr.mergeable_state === "clean") {
                  return pr
                }
                console.log(`Waiting... mergeable=${pr.mergeable} state=${pr.mergeable_state}`)
                await sleep(delayMs)
              }
              return pr
            }

            async function tryMerge(number) {
              const pr = await waitForMergeable(number)
              if (!pr || pr.merged) return
              if (pr.mergeable !== true || pr.mergeable_state !== "clean") {
                if (pr.mergeable_state === "dirty") {
                  await postConflictComment(pr)
                }
                console.log(`PR #${number} not mergeable yet`)
                return
              }

              try {
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: number,
                  merge_method: "merge"
                })
                console.log(`Merged PR #${number}`)
                await commentOnce(pr.number, mergeMarker("success"), [
                  "FR: Merge automatique reussi.",
                  "EN: Auto-merge succeeded."
                ])
              } catch (error) {
                if (error.status === 405 || error.status === 409) {
                  console.log(`Merge skipped for PR #${number}: ${error.message}`)
                  await commentOnce(pr.number, mergeMarker("skipped"), [
                    `FR: Merge automatique ignore (${error.message}).`,
                    `EN: Auto-merge skipped (${error.message}).`
                  ])
                  return
                }
                throw error
              }
            }

            if (action === "requested" || action === "in_progress") {
              const stage = action
              const lines = [
                `FR: Checks en cours (${stage}).`,
                `EN: Checks are running (${stage}).`,
                `Run: ${runUrl}`
              ]
              for (const pr of prs) {
                await commentOnce(pr.number, statusMarker(stage), lines)
              }
              return
            }

            if (action !== "completed") {
              console.log(`Unsupported action: ${action}`)
              return
            }

            const jobs = await getRunJobs(runId)
            const jobLines = formatJobSummary(jobs)
            const conclusion = run.conclusion || "unknown"
            const clamavJob = jobs.find((job) => job.name === "clamav")
            const clamavStatus = clamavJob?.conclusion || clamavJob?.status || "missing"
            const virusDetected = clamavJob?.conclusion === "failure"

            const statusLines = virusDetected
              ? [
                  `FR: Checks termines, ClamAV a detecte un malware. Merge automatique bloque.`,
                  `EN: Checks completed, ClamAV detected malware. Auto-merge is blocked.`,
                  `Run: ${runUrl}`,
                  ...jobLines
                ]
              : checksOk
                ? [
                    `FR: Checks termines avec succes. Tentative de merge automatique.`,
                    `EN: Checks completed successfully. Attempting auto-merge.`,
                    `Run: ${runUrl}`,
                    ...jobLines
                  ]
                : [
                    `FR: Checks termines en echec (conclusion: ${conclusion}). Merge automatique tente quand meme si pas de conflit.`,
                    `EN: Checks completed with failure (conclusion: ${conclusion}). Auto-merge will still be attempted if no conflicts.`,
                    `Run: ${runUrl}`,
                    ...jobLines
                  ]

            for (const pr of prs) {
              await commentOnce(pr.number, statusMarker(checksOk ? "success" : "failure"), statusLines)
              if (virusDetected) {
                await commentOnce(pr.number, virusMarker("detected"), [
                  `FR: ClamAV a detecte un malware (etat: ${clamavStatus}).`,
                  `EN: ClamAV detected malware (status: ${clamavStatus}).`,
                  `Run: ${runUrl}`
                ])
                continue
              }
              await tryMerge(pr.number)
            }
